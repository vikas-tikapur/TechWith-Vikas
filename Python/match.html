<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TechWith Vikas</title>
  <link rel="stylesheet" href="../style.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">

<header class="main-header">
  <div class="container">
    <div><a href="../index.html" class="logo">TechWith <span>Vikas</span></a></div>
    <select id="pythonPagesDropdown" onchange="if(this.value) window.location.href=this.value;">
      <div class="custom-dropdown">
      <option value="">Go to Python Topic...</option>
      <option value="python.html">Python Introduction</option>
      <option value="python_p1.html">Python Syntax</option>
      <option value="python_p2.html">Python Comments & Variables</option>
      <option value="python_p3.html">Python Data Types/List</option>
      <option value="python_p4.html">Python Tuples</option>
      <option value="python_p6.html">Python Quiz-1</option>
      <option value="python_p7.html">Python Sets</option>
      <option value="python_p8.html">Python Dictionaries</option>
      <option value="ifelse.html">Python If/Else</option>
      <option value="match.html">Python Match</option>
      <option value="loops.html">Python Loops</option>
      <option value="functions.html">Python Functions</option>
      <option value="array.html">Python Arrays</option>
      <option value="oops.html">Python OOP</option>
    </select>
  </div>
</header>



<section class="python-intro">
  <div class="container">
    <h2>Python Match</h2>
    <p><b>Python's match Statement: Structural Pattern Matching (Python 3.10+)</b></p>
    <p>The <b>match</b> statement allows you to compare a <b>subject</b> (an expression) against several <b>patterns</b> and 
      execute a block of code when a pattern matches. It's a more declarative and often more readable 
      alternative to long <b>if-elif-else</b> chains, particularly when your conditions involve inspecting the 
      structure or shape of data.</p>

    <p>It's inspired by pattern matching features found in functional programming languages.</p>
<br><br>
    <h3><b>1. Basic match Statement:</b></h3>
    <p>The simplest form involves matching a single value against literal patterns.</p>
    <h3><b>Syntax : </b></h3>
    <div class="Code-box">
    <pre><code>match subject:
    case pattern1:
        # Code to execute if subject matches pattern1
    case pattern2:
        # Code to execute if subject matches pattern2
    case _: # The "wildcard" pattern (like 'else')
        # Code to execute if no other pattern matches
</code></pre>
  </div>
  <br><br>

  <h3><b>Key Points :</b></h3>
    <ul>
        <li><b>subject:</b> The expression whose value you want to match.</li>
        <li><b>case:</b> Introduces a pattern.</li>
        <li><b>pattern:</b> What you are trying to match the <b>subject</b> against.</li>
        <li><b>_ (Wildcard Pattern):</b> Catches anything that hasn't been matched by previous <b>case</b> statements. 
          It acts like an <b>else</b> block and should typically be the last <b>case</b>.</li>
    </ul><br>
    <h3><b>Example 1.1: Matching a string (commands) : </b></h3>
    <div class="Code-box">
    <pre><code>command = "start"
match command:
    case "start":
        print("System is starting...")
    case "stop":
        print("System is shutting down.")
    case "restart":
        print("System is restarting now.")
    case _: # Default case if no match found
        print(f"Unknown command: '{command}'")
# Another example:
command = "status"
match command:
    case "start":
        print("System is starting...")
    case "stop":
        print("System is shutting down.")
    case "restart":
        print("System is restarting now.")
    case _:
        print(f"Unknown command: '{command}'")
</code></pre>
  </div>
 
<h3><b>Explanation :</b></h3>
<p>The <b>command</b> variable is the <b>subject</b>. Each case checks if <b>command</b> exactly matches the string literal 
  ("start", "stop", "restart"). If <b>command</b> is "status", it doesn't match any of the explicit cases, so 
  the wildcard <b>_</b> case is executed.
</p>

<br><br>
<h3><b>2. Matching Multiple Literals with | (OR operator) :</b></h3>
<p>You can match against multiple literal values using the <b>|</b> (OR) operator within a single <b>case</b>.</p><br>
<h3>Example 2.1: Matching multiple HTTP status codes :</h3>
<div class="Code-box">
<pre><code>status_code = 403
match status_code:
    case 200:
        print("OK: Request successful.")
    case 400 | 401 | 403 | 404: # Matches any of these client errors
        print("Client Error: Please check your request or authentication.")
    case 500 | 502 | 503: # Matches any of these server errors
        print("Server Error: Something went wrong on the server side.")
    case _:
        print(f"Unhandled status code: {status_code}")
</code></pre>
  </div>

<h3><b>Explanation :</b></h3>
<p>If <b>status_code</b> is 403, it matches <b>400 | 401 | 403 | 404</b> and the corresponding message is printed.</p>

<br><br>
<h3><b>3. Capturing Patterns (Variable Patterns) :</b></h3>
<p>You can capture parts of the subject into variables for later use within the <b>case</b> block. 
  This is done by using a variable name as a pattern.</p><br>
<h3><b>Example 3.1: Capturing a simple value :</b></h3>
<div class="Code-box">
<pre><code>action = "download"
match action:
    case "upload":
        print("Initiating file upload.")
    case "download" as file_action: # Captures "download" into file_action
        print(f"Initiating file {file_action}.")
    case cmd: # Captures any other value into 'cmd'
        print(f"Executing generic command: {cmd}")
# Another example:
action = "process"
match action:
    case "upload":
        print("Initiating file upload.")
    case "download" as file_action:
        print(f"Initiating file {file_action}.")
    case cmd: # 'process' is captured by 'cmd'
        print(f"Executing generic command: {cmd}")
</code></pre>
  </div>

<h3><b>Explanation :</b></h3>
<p>When <b>action</b> is "download", it matches <b>case "download" as file_action:</b>, and the string 
  "download" is assigned to the <b>file_action</b> variable. If <b>action</b> is "process", it doesn't match 
  the specific literals, so it falls to <b>case cmd:</b>, and "process" is assigned to <b>cmd</b>.</p>
<br><br>

<h3><b>4. Matching Sequence Patterns (Lists and Tuples) :</b></h3>
<p>You can match against the structure and elements of sequences like lists and tuples.</p>
<br><br>

<h3><b>Key Points: </b></h3>
<ul>
  <li><b>Exact length matching:</b> case [a, b, c] will only match a list of exactly three elements.</li>
  <li><b>Star pattern (*):</b>Matches zero or more elements. It captures them into a list. <b>*</b> can appear only once in a sequence pattern.</li>
  <li><b>Nested patterns:</b> You can nest patterns within sequences.</li>
</ul><br><br>

<h3><b>Example 4.1: Matching coordinates :</b></h3>
<div class="Code-box">
<pre><code>point1 = (1, 2)
point2 = [5, 10, 15]
point3 = (0, 0)
point4 = (3, -1)
for point in [point1, point2, point3, point4]:
    match point:
        case (0, 0):
            print(f"{point}: Origin.")
        case (x, y): # Matches any tuple of two elements, captures them into x, y
            print(f"{point}: Point at ({x}, {y}).")
        case [x, y, z]: # Matches a list of three elements
            print(f"{point}: 3D point at [{x}, {y}, {z}].")
        case _:
            print(f"{point}: Unrecognized point format.")
</code></pre>
  </div>

<h3><b>Explanation :</b></h3>
<ul>
  <li><b>(0, 0)</b> matches the specific literal tuple.</li>
  <li><b>(x, y)</b> matches any 2-element tuple, capturing its elements.</li>
  <li><b>[x, y, z]</b> matches any 3-element list.</li>
  <li><b>_</b> matches anything else, acting as a catch-all.</li>
</ul>
<br><br>

<h3><b>Example 4.2: Using the star pattern * (variable-length sequences)</b></h3>
<div class="Code-box">
<pre><code>data_entry1 = ["log", "info", "User logged in."]
data_entry2 = ["error", "Permission denied.", "main.py", 102]
data_entry3 = ["event", "App startup"]
for entry in [data_entry1, data_entry2, data_entry3]:
    match entry:
        case ["log", level, message]: # Matches a 3-element list with specific first element
            print(f"LOG ({level.upper()}): {message}")
        case ["error", message, *details]: # Matches "error", captures message, and remaining elements into 'details' list
            print(f"ERROR: {message} (Details: {details})")
        case ["event", *args]: # Matches "event" and captures remaining elements into 'args'
            print(f"EVENT: {args}")
        case _:
            print(f"Unknown data entry: {entry}")
</code></pre>
  </div>
<h3><b>Explanation :</b></h3>
<ul>
  <li><b>["log", level, message]</b> requires exactly 3 elements, starting with "log". <b>level</b> and <b>message</b> capture the second and third elements.</li>
  <li><b>["error", message, *details]</b>  requires at least 2 elements, starting with "error". 
    <b>message</b> captures the second, and <b>details</b> captures all subsequent elements as a list (can be empty).</li>
</ul>

<br><br>
<h3><b>5. Matching Mapping Patterns (Dictionaries):</b></h3>
<p>You can match against the structure and keys/values of dictionaries.</p><br>
<h3><b>Key Points: </b></h3>
<ul>
  <li>You can specify required keys and capture their values.</li>
  <li><b>**rest </b> (double-star) captures remaining key-value pairs into a new dictionary.</li>
</ul><br><br>

<h3><b>Example 5.1: Matching user profiles :</b></h3>
<div class="Code-box">
<pre><code>user1 = {"name": "Alice", "age": 30, "city": "New York"}
user2 = {"name": "Bob", "role": "admin"}
user3 = {"username": "charlie_dev"}
user4 = {"name": "David", "age": 17, "status": "active"}
for user in [user1, user2, user3, user4]:
    match user:
        case {"name": name, "age": age} if age >= 18: # Matches if 'name' and 'age' keys exist, and age is >= 18
            print(f"Adult User: {name}, Age: {age}")
        case {"name": name, "age": age}: # Matches if 'name' and 'age' keys exist (any age)
            print(f"Minor User: {name}, Age: {age}")
        case {"name": name, "role": role}: # Matches if 'name' and 'role' keys exist
            print(f"User with Role: {name}, Role: {role}")
        case {"name": name, **other_info}: # Matches if 'name' exists, captures rest into other_info dict
            print(f"User (Name only): {name}, Other info: {other_info}")
        case _:
            print(f"Unknown user format: {user}")
</code></pre>
</div>
<h3><b>Explanation :</b></h3>
<ul>
  <li><b>{"name": name, "age": age}</b> matches if both <b>name</b> and <b>age</b> keys are present. Their values are 
    captured into <b>name</b> and <b>age</b> variables.</li>
</ul>

<br><br>
<h3><b>6. Guards (if clauses in case):</b></h3>
<p>You can add an <b>if</b> clause (a "guard") to a <b>case</b> pattern. The <b>case</b> only matches if both the pattern 
  matches and the <b>if</b> condition is true.</p>
  <h3><b>Syntax:</b></h3>
<div class="Code-box">
<pre><code>case pattern if condition:
    # Code to execute if pattern matches AND condition is True
</code></pre>
</div>
<br>
<h3><b>Key Points: </b></h3>
<ul>
  <li>The <b>condition</b> can use any variables captured by the pattern.</li>
  <li>Guards allow for more fine-grained control beyond just structural matching.</li> 
</ul>
<br><br>

<h3><b>Example 6.1: Filtering numbers</b></h3>
<div class="Code-box">
<pre><code>num = 7
match num:
    case n if n % 2 == 0:
        print(f"{n} is an even number.")
    case n if n % 2 != 0:
        print(f"{n} is an odd number.")
    case _:
        print("Not a number?")
</code></pre>
</div>
<br><br>

<h3><b>Example 6.2: Combining patterns and guards (from user profile example) </b></h3>
<div class="Code-box">
<pre><code>user = {"name": "Charlie", "age": 15, "city": "London"}
match user:
    case {"name": name, "age": age} if age >= 18:
        print(f"Adult user {name} ({age}).")
    case {"name": name, "age": age} if age < 18:
        print(f"Minor user {name} ({age}).")
    case {"name": name, **details}:
        print(f"User {name} with other details: {details}")
    case _:
        print("Invalid user data.")
</code></pre>
</div>

<h3><b>Explanation :</b></h3>
<p>The <b>if age >= 18</b> acts as a guard. The <b>case</b> will only activate if <b>user</b> has <b></b>name</b> and <b>age</b> keys and
  the value of <b>age</b> is 18 or greater.</p>
<br><br>

<h3><b>7. Class Patterns (Matching Objects):</b></h3>
<p>This is one of the most powerful features. You can match against instances of classes and extract attributes.</p>

<h3><b>Syntax </b></h3>
<div class="Code-box">
<pre><code>case ClassName(attribute1=var1, attribute2=var2, ...):
    # Code to execute if subject is an instance of ClassName
    # and attributes match/are captured
</code></pre>
</div>

<h3><b>Key Points: </b></h3>
<ul>
  <li>The <b>match</b> statement calls <b>__match_args__</b> (if defined in the class) or looks for attributes by name.</li>
  <li>You can mix literal values for attributes or capture them into variables.</li>
  <li>You can use nested class patterns.</li>
</ul>
<br><br>

<h3><b>Example 7.1: Matching geometric shapes</b></h3>
<div class="Code-box">
<pre><code>class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    # Optional: Define __match_args__ for positional matching (more advanced)
    def __match_args__(self):
        return ("x", "y")

class Circle:
    def __init__(self, center, radius):
        self.center = center # center is a Point object
        self.radius = radius
    def __match_args__(self):
        return ("center", "radius") # Allows matching like Circle(Point(x,y), r)

class Rectangle:
    def __init__(self, top_left, bottom_right):
        self.top_left = top_left
        self.bottom_right = bottom_right

# Create some shape instances
p1 = Point(10, 20)
p_origin = Point(0, 0)
c1 = Circle(Point(5, 5), 10)
r1 = Rectangle(Point(0, 10), Point(20, 0))
shapes = [p1, p_origin, c1, r1, "not a shape"]

for shape in shapes:
    match shape:
        case Point(0, 0): # Matches Point object where x is 0 and y is 0
            print(f"Shape: Origin Point at ({shape.x}, {shape.y})")
        case Point(x=x_coord, y=y_coord): # Matches any Point object, captures x and y
            print(f"Shape: Generic Point at ({x_coord}, {y_coord})")
        case Circle(center=Point(cx, cy), radius=r): # Nested pattern: Circle with a Point center
            print(f"Shape: Circle centered at ({cx}, {cy}) with radius {r}")
        case Rectangle(top_left=Point(tx, ty), bottom_right=Point(bx, by)):
            print(f"Shape: Rectangle from ({tx}, {ty}) to ({bx}, {by})")
        case _:
            print(f"Shape: Unknown/Unmatched ({type(shape)})")
</code></pre>
</div>

<h3><b>Explanation :</b></h3>
<ul>
  <li><b>Point(0, 0):</b> Matches a <b>Point</b> object whose <b>x</b> and <b>y</b> attributes are both 0.</li>
  <li><b>Point(x=x_coord, y=y_coord):</b> Matches any <b>Point</b> object and captures its  <b>x</b> and <b>y</b> attributes into new variables <b>x_coord</b> and <b>y_coord</b>.</li>
  <li><b>Circle(center=Point(cx, cy), radius=r):</b> This is a <b>nested class pattern</b>. It matches a <b>Circle</b> object. 
    Inside the <b>Circle</b> pattern, it expects a <b>center</b> attribute which itself must be a <b>Point</b> object. 
    It then extracts <b>cx</b> and <b>cy</b> from that nested <b>Point</b> and <b>r</b> from the <b>Circle</b>'s radius attribute.</li>
</ul>
<br><br>

<h3><b>8. as keyword for Alias (Subpatterns) :</b></h3>
<p>You can use the <b>as</b> keyword to give an alias to a subpattern, allowing you to refer to the matched part of the subject directly.</p>
<br>
<h3><b>Example 8.1: Capturing the entire matched object or sub-structure</b></h3>
<div class="Code-box">
<pre><code>data_item1 = ["command", "start"]
data_item2 = ("log", "info", "User logged in.")
data_item3 = {"type": "user", "id": 123}

for item in [data_item1, data_item2, data_item3]:
    match item:
        case ["command", action] as full_command: # Captures 'action' and the entire list as 'full_command'
            print(f"Detected command: {action} (Full: {full_command})")
        case ("log", level, _) as log_entry if level == "error": # Captures level, ignores third, and captures full tuple
            print(f"Critical Log Entry: {log_entry}")
        case {"type": "user", "id": user_id} as user_obj: # Captures user_id and the entire dict as user_obj
            print(f"Matched User object: ID {user_id}, Object: {user_obj}")
        case _:
            print(f"Unmatched item: {item}")
</code></pre>
</div>

<h3><b>Explanation :</b></h3>
<p>In <b>case ["command", action] as full_command:, action</b> gets the second element, and <b>full_command</b> gets
  the entire list <b>["command", "start"]</b>. This is useful when you need to inspect individual parts but also
  operate on the whole matched structure.</p>

  <br><br>
<h3><b>9. Underscore _ as a Wildcard or Ignored Value :</b></h3>
<p>The underscore <b>_</b> has two main uses:</p>
<ul>
  <li><b>Wildcard Pattern:</b>  As seen in <b>case _:</b>, it matches anything and is used as the default.</li>
  <li><b>Ignored Value:</b> Within a pattern,<b> _ </b> means "match this position/attribute, but I don't care about its value, so don't bind it to a variable."</li>
</ul><br>

<h3><b>Example 9.1: Ignoring values in sequence patterns</b></h3>
<div class="Code-box">
<pre><code>point_3d = (10, 20, 30)
point_2d = (5, 8)
invalid_point = (1, 2, 3, 4)

for p in [point_3d, point_2d, invalid_point]:
    match p:
        case (x, y, _): # Matches a 3-element tuple, captures first two, ignores third
            print(f"3D point (first two coords): ({x}, {y})")
        case (x, _): # Matches a 2-element tuple, captures first, ignores second
            print(f"2D point (first coord): ({x})")
        case _:
            print(f"Not a recognized point: {p}")
</code></pre>
</div>

<h3><b>Explanation :</b></h3>
<p><b>case (x, y, _)</b> matches <b>(10, 20, 30)</b>, captures <b>10</b> to <b>x</b>, <b>20</b> to <b>y</b>, and discards <b>30</b>.</p>

<br><br>
<h3><b>Advantages of match-case over if-elif-else :</b></h3>
<ol>
  <li><b>Readability:</b> Especially for complex, nested data structures, <b>match</b> makes the code much cleaner and
     easier to understand by explicitly showing the expected structure.</li>
  <li><b>Exhaustiveness Checks (potential future tooling):</b> While not a built-in feature of Python's 
    runtime, pattern matching in other languages often allows static analysis tools to warn you if you 
    haven't covered all possible cases, which could be a future benefit for Python.</li>
  <li><b>Conciseness:</b> It can significantly reduce boilerplate code compared to multiple <b>if</b> and <b>and</b> conditions.</li>
  <li><b>No Fall-through:</b> Unlike some other languages (like C's <b>switch</b>), 
    Python's <b>match</b> does not fall through. Only the first matching <b>case</b> is executed.</li>
<li><b>Direct Deconstruction:</b> It directly deconstructs values (like extracting elements from a list or 
  attributes from an object) into variables, which reduces manual assignments.</li>
</ol>
<br><br>

  <h3><b>When to use match-case? </b></h3>
    <ul>
      <li><b>Handling different types of data/objects:</b> When your logic depends on the type or class of 
        an object.</li>
      <li><b>Processing structured data:</b> Ideal for parsing messages, commands, or data from APIs where 
        the shape of the data varies.</li>
      <li><b>Finite state machines:</b> When your program's behavior changes based on its current state and incoming events.</li>
      <li><b>Replacing long if-elif-else chains</b>  that primarily check the type or structure of a variable.</li>
    </ul>
  
    <br><br>
  <h3><b>When if-elif-else might still be better?</b></h3>
  <ul>
    <li><b>Simple boolean conditions:</b> When you're just checking if a single variable is greater than, 
      less than, or equal to a value, <b>if-elif-else</b> is often more direct.</li>
    <li><b>Complex arithmetic or logical operations:</b> If your conditions involve extensive calculations
       or complex <b>and/or</b> combinations that don't involve deconstructing data.</li>
    <li><b>Python versions older than 3.10:</b> Obviously, <b>match</b> is not available.</li>
  </ul><br><br>

<h3><b>Here are 5 simple and easy-to-understand examples of the match statement in Python:</b></h3>
<p> <b>🔒Note:</b> These examples require  <b>Python 3.10 or higher.</b> </p>
<br><br>

  <h3><b> Example 1: Match a String</b></h3>
  <div class="Code-box">
    <pre><code>day = "Sunday"
match day:
    case "Monday":
        print("Start of the week")
    case "Sunday":
        print("Relax! It's weekend.")
    case _:
        print("Just a regular day")

#Output- Relax! It's weekend.
</code></pre>
  </div>
<br><br>

  <h3><b>Example 2: Match a Number</b></h3>
  <div class="Code-box">
    <pre><code>number = 5

match number:
    case 1:
        print("One")
    case 5:
        print("Five")
    case _:
        print("Unknown number")
#Output- Five
</code></pre>
  </div>

  <br><br>
  <h3><b>Example 3: Match with Multiple Values</b></h3>
  <div class="Code-box">
    <pre><code>fruit = "apple"
match fruit:
    case "apple" | "banana" | "mango":
        print("It's a fruit we love!")
    case _:
        print("It's some other fruit.")
#Output- It's a fruit we love!
</code></pre>
  </div>

  <br><br>

  <h3><b>Example 4: Match a Tuple</b></h3>
  <div class="Code-box">
    <pre><code>point = (0, 5)

match point:
    case (0, 0):
        print("Origin")
    case (0, y):
        print(f"Y-axis at y = {y}")
    case (x, 0):
        print(f"X-axis at x = {x}")
    case (x, y):
        print(f"Point is at ({x}, {y})")
#Output- Y-axis at y = 5
</code></pre>
  </div>

  <br><br>
  <h3><b>Example 5: Match with Condition (Guard)</b></h3>
  <div class="Code-box">
    <pre><code>age = 17

match age:
    case x if x < 18:
        print("You are a minor.")
    case x if x >= 18:
        print("You are an adult.")
#Output- You are a minor.
</code></pre>
  </div>

<h2><b>Conclusion :</b></h2>
<p>The <b>match</b> statement is a powerful addition to Python's control flow mechanisms. It encourages a 
  more declarative style of programming when dealing with varied data structures and provides a cleaner, 
  more readable way to express complex conditional logic. While it takes some getting used to, mastering
   <b>match</b> will undoubtedly make your Python code more elegant and maintainable for many real-world
    scenarios.</p>





<br><br>



  <div class="navigation-buttons">
  <a href="ifelse.html" class="nav-btn prev-btn">← Previous</a>
  <a href="loops.html" class="nav-btn next-btn">Next →</a>
</div>
</section>



<footer class="footer">
  <div class="footer-container">
    <div class="footer-left">
      <h2>CodeWith <span>Vikas</span></h2>
      <p>Learn programming from scratch.<br> Start your journey today!</p>
    </div>

    <div class="footer-links">
      <h3>Quick Links</h3>
      <ul>
        <li><a href="#">Home</a></li>
        <li><a href="#">Python</a></li>
        <li><a href="#">Java</a></li>
        <li><a href="#">Contact</a></li>
      </ul>
    </div>

    <div class="footer-social">
      <h3>Follow Me</h3>
      <a href="#"><i class="fab fa-facebook-f"></i></a>
      <a href="#"><i class="fab fa-x"></i></a>
      <a href="#"><i class="fab fa-instagram"></i></a>
      <a href="#"><i class="fab fa-github"></i></a>
    </div>
  </div>

  <div class="footer-bottom">
    <p>&copy; 2025 TechWith Vikas | Created by Vikas Mishra</p>
  </div>
<div class="scroll-to-top" title="Go to Top">
  <i class="fa fa-arrow-up"></i>
</div>
</footer>

<script src="../main.js"></script>
</body>
</html>
