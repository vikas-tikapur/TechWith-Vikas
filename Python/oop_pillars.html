<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TechWith Vikas</title>
  <link rel="stylesheet" href="../style.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">

<header class="main-header">
  <div class="container">
    <div><a href="../index.html" class="logo">TechWith <span>Vikas</span></a></div>
    <select id="pythonPagesDropdown" onchange="if(this.value) window.location.href=this.value;">
      <div class="custom-dropdown">
      <option value="">Go to Python Topic...</option>
      <option value="python.html">Python Introduction</option>
      <option value="python_p1.html">Python Syntax</option>
      <option value="python_p2.html">Python Comments & Variables</option>
      <option value="python_p3.html">Python Data Types/List</option>
      <option value="python_p4.html">Python Tuples</option>
      <option value="python_p6.html">Python Quiz-1</option>
      <option value="python_p7.html">Python Sets</option>
      <option value="python_p8.html">Python Dictionaries</option>
      <option value="ifelse.html">Python If/Else</option>
      <option value="match.html">Python Match</option>
      <option value="loops.html">Python Loops</option>
      <option value="functions.html">Python Functions</option>
      <option value="array.html">Python Arrays</option>
      <option value="oops.html">Python OOP</option>
    </select>
  </div>
</header>



<section class="python-intro">
  <div class="container">
    <h2>Four Pillars of OOP</h2> 
    <p><b>1. Encapsulation :</b> (Data hiding)</p>
    <p><b>2. Abstraction :</b> (Hiding Complexity)</p>
    <p><b>3. Inheritance :</b> (Reusing Code)</p>
    <p><b>4. Polymorphism :</b> (Many Forms)</p>
<br>
<h2><b>1. Encapsulation :</b></h2>
<p><b>Encapsulation</b> means <b> binding variables (data)</b> and <b>methods (functions)</b> together into a <b>single unit (class)</b> i.e. called <b>Encapsulation.</b></p>
<br>
<h3><b>Key Points :</b></h3>
<ul>
    <li>It is a fundamental concept in <b>Object-Oriented Programming (OOP).</b></li>
    <li>It allows for <b>data hiding</b> and <b>controlled access</b> using methods.</li>
    <li><b>Encapsulation</b> protects an object from <b>unwanted access</b> and <b>modification.</b></li>
</ul><br>

<h3><b>Simplified Explanation :</b></h3>
<p>Think of a <b>capsule</b> in medicine ‚Äî it holds different components inside. <br>
Similarly, a <b>class in Python</b> holds both <b>data (variables)</b> and <b>behavior (methods)</b> together.</p>
<br>

<h3><b>Example :</b></h3>
<div class="Code-box">
    <pre><code>class Student:
    def __init__(self):
        self.__name = None   # Private variable

    def set_name(self, name):   # Public method to set name
        self.__name = name

    def get_name(self):         # Public method to get name
        return self.__name

# Using the class
s = Student()
s.set_name("Tanay")
print(s.get_name())   # Output: Tanay
</code></pre>
  </div>
<br><br>

<h3><b>üîí Note :</b></h3>
<ul>
    <li><b>__name</b> is a <b>private variable</b> (name mangling used for encapsulation).</li>
    <li>Access is <b>controlled</b> via public methods <b>set_name()</b> and <b>get_name().</b></li>
</ul><br><br>

<h3><b>Benefits of Encapsulation :</b></h3><br>
<div class="responsive-table-wrapper">
<table class="array-methods-table">
  <thead>
    <tr>
      <th>Benefit</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code> Data Hiding</code></td>
      <td>Prevents direct access to data</td>
    </tr>

    <tr>
      <td><code>Modularity</code></td>
      <td>Keeps code organized and reusable</td>
    </tr>

    <tr>
      <td><code>Control</code></td>
      <td>Allows validation logic before modifying variables</td>
    </tr>

    <tr>
      <td><code>Flexibility</code></td>
      <td>Internal implementation can change without affecting external code</td>
    </tr>
  </tbody>
</table>
</div><br><br>

<h3><b>One-Line Summary : </b></h3>
<p><b>Encapsulation</b> = wrapping <b>data + methods</b> into a <b>single unit</b> (class) and hiding internal details from the outside.</p>
<br><br>

<h3><b>Using Default Arguments in Python Constructor (__init__).</b></h3>
<div class="Code-box">
    <pre><code>class Student:
    def __init__(self, name="Tenali Rama", marks=50):
        self.name = name
        self.marks = marks

# Create two Student objects
s1 = Student()                    # Uses default values
s2 = Student("Krishndev", 25)     # Uses custom values

# Print details
print("Name: {} marks: {}".format(s1.name, s2.marks))
print("Name: {} marks: {}".format(s2.name, s2.marks))

# Output : 
Name: Tenali Rama marks: 25
Name: Krishndev marks: 25
</code></pre>
  </div>
<br><br>

<h3><b>Add Salary & Project Display Feature in HR Management System.</b></h3>
<div class="Code-box">
    <pre><code>class Employee:
    # Constructor to initialize employee details
    def __init__(self, name, id, salary, project):
        self.name = name         # Employee name
        self.id = id             # Employee ID
        self.salary = salary     # Employee salary
        self.project = project   # Project assigned

    # Method to show salary details
    def show_sal(self):
        print("Name:", self.name, "Salary:", self.salary)

    # Method to show project information
    def proj(self):
        print(self.name, "is working on", self.project)

# Creating an object of Employee
emp = Employee('Rohit', 102, 100000, 'Python')

# Calling methods
emp.show_sal()
emp.proj()

# Output : 
Name: Rohit Salary: 100000
Rohit is working on Python
</code></pre>
  </div>

<br><br>

<h3><b>Create an Employee Class with Constructor and Display Method.</b></h3>
<div class="Code-box">
    <pre><code>class Employee:
    def __init__(self, name, age):
        self.name = name  # Instance variable for employee name
        self.age = age    # Instance variable for employee age

    def display(self):
        print("Employee Name:", self.name)
        print("Employee Age:", self.age)

# Creating an object of Employee class
s = Employee("Kartik Singh", 22)

# Calling the display method
s.display()

# Output : 
Employee Name: Kartik Singh
Employee Age: 22
</code></pre>
  </div>
<br><br>

<h2><b>2. Abstraction :</b></h2>
<p><b>Abstraction</b> is the concept of <b>hiding unnecessary internal details</b> and <b>showing only the essential features</b> to the user.</p>
<br>
<h3><b>Simple Example :</b></h3>
<p>Think about a TV remote :</p>
<ul>
    <li>You press a button to change the channel.</li>
    <li>You don‚Äôt need to know <b>how</b> the internal circuitry works.</li>
</ul>
<p>That‚Äôs <b>abstraction</b> ‚Äî hiding complex internal logic, and showing only what the user needs.</p><br>

<h3><b>Key Points :</b></h3>
<p>It focuses on what an object does, not how it does it.</p>
<p>Achieved in Python using :</p>
<ul>
    <li><b>Abstract Base Classes (ABC).</b></li>
    <li><b>Interfaces (via abstract methods).</b></li>
</ul>
<br><br>

<h3><b>Code Example using abc module :</b></h3>
<div class="Code-box">
    <pre><code>from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

class Rectangle(Shape):
    def __init__(self, length, width):
        self.length = length
        self.width = width

    def area(self):
        return self.length * self.width

# obj = Shape()         # ‚ùå Can't instantiate abstract class
rect = Rectangle(10, 5) #  Concrete class
print("Area:", rect.area())

# Output : 
Area: 50
</code></pre>
  </div>
  <br><br>

<h3><b>Why Use Abstraction?</b></h3>
<br>
<div class="responsive-table-wrapper">
<table class="array-methods-table">
  <thead>
    <tr>
      <th>Benefit</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>Clean Code</code></td>
      <td>Keeps code organized and modular</td>
    </tr>

    <tr>
      <td><code>Security</code></td>
      <td>Hides implementation details</td>
    </tr>

    <tr>
      <td><code>Flexibility</code></td>
      <td>Easy to update or modify logic</td>
    </tr>

    <tr>
      <td><code>Reusability</code></td>
      <td>Promotes reusable components</td>
    </tr>
  </tbody>
</table>
</div><br><br>

<h3><b>Examples of Data Abstraction Using Abstract Classes in Python :</b></h3>
<p>In Python, it is implemented using :</p>
<ul>
    <li><b>ABC</b> (Abstract Base Class)</li>
    <li><b>@abstractmethod</b> decorator</li>
</ul>
<div class="Code-box">
    <pre><code>from abc import ABC, abstractmethod
class Animal(ABC):

    # Concrete method
    def sleep(self):
        print("I am going to sleep in a while")

    @abstractmethod
    def sound(self):
        print("This function is for defining the sound by any animal")

# Subclasses implementing abstract method
class Snake(Animal):
    def sound(self):
        print("I can hiss")

class Dog(Animal):
    def sound(self):
        print("I can bark")

class Lion(Animal):
    def sound(self):
        print("I can roar")

class Cat(Animal):
    def sound(self):
        print("I can meow")

# Creating objects and calling methods
c = Cat()
c.sleep()   # Inherited concrete method
c.sound()   # Overridden abstract method

c = Snake()
c.sound()

# Output : 
I am going to sleep in a while
I can meow
I can hiss
</code></pre>
  </div>
  <br>

<h2><b>3. Inheritance :</b></h2>
<p><b>Inheritance</b> is a core concept in Object-Oriented Programming (OOP) that allows a class (child/subclass) to inherit the properties and methods of another class (parent/superclass).
It promotes <b>code reusability</b> and reflects <b>real-world relationships.</b></p>
<br>
<h3><b>In Simple Terms :</b></h3>
<ul>
    <li><b>Inheritance</b> used <b>code reusability.</b></li>
    <li><b>Inheritance</b> is a <b>relationship between two or more classes.</b> </li>
    <li><b>Inheritance</b> is a <b>real-world relationship.</b></li>
</ul> <br><br>

<h3><b>Key Concepts :</b></h3>
<br>
<div class="responsive-table-wrapper">
<table class="array-methods-table">
  <thead>
    <tr>
      <th>Term</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>Superclass</code></td>
      <td>The class whose properties are inherited</td>
    </tr>

    <tr>
      <td><code>Subclass</code></td>
      <td>The class that inherits from superclass</td>
    </tr>

    <tr>
      <td><code>Code Reusability</code></td>
      <td>Avoids writing the same code again</td>
    </tr>
  </tbody>
</table>
</div><br><br>

<h2><b>Why Use Inheritance?</b></h2>
<ul>
  <li>Reuse common logic</li>
  <li>Promote DRY (Don't Repeat Yourself) principle</li>
  <li>Better structure & modularity</li>
  <li>Easy to extend functionality</li>
</ul>
<br>

<h2><b>Types of Inheritance :</b></h2>
<ol>
  <li>Single Inheritance</li>
  <li>Multilevel Inheritance</li>
  <li>Multiple Inheritance</li>
  <li>Hierarchical Inheritance</li>
  <li>Hybrid Inheritance</li>
</ol>
<br>

<h3><b>Single Inheritance :</b></h3>
<p>In <b>Single Inheritance</b>, a child (subclass) inherits from <b>only one parent class</b> (superclass). <br>
It allows the child class to <b>reuse the code</b> (methods, variables) from the parent.</p>
<br>
<h3><b>Structure :</b></h3>
<div class="Code-box">
    <pre><code>Parent Class
   ‚Üì
Child Class
</code></pre>
  </div>
<br>

<h3><b>Example :</b></h3>
<div class="Code-box">
    <pre><code>class P:
    def m1(self):
        print("Parent method")

class C(P):  # Inheriting from class P
    def m2(self):
        print("Child method")

# Creating object of child class
c = C()
c.m1()   # Inherited from parent
c.m2()   # Defined in child

# Output : 
Parent method  
Child method
</code></pre>
  </div>

  <br><br>

<h3><b>Multilevel Inheritance :</b></h3>
<p>In <b>Multilevel Inheritance,</b> a class inherits from a <b>child class,</b> which itself inherits from a <b>parent class.</b> <br>
This forms a <b>chain of inheritance,</b> like <b>Grandparent ‚Üí Parent ‚Üí Child.</b></p>
<br>
<h3><b>Structure :</b></h3>
<div class="Code-box">
    <pre><code>Parent Class (P)
       ‚Üì
Child Class (C)
       ‚Üì
Sub-Child Class (CC)
</code></pre>
  </div>
<br>

<h3><b>Example :</b></h3>
<div class="Code-box">
    <pre><code>class P:
    def m1(self):
        print("Parent method")

class C(P):  # Inheriting from P
    def m2(self):
        print("Child method")

class CC(C):  # Inheriting from C
    def m3(self):
        print("Sub-child method")

# Creating object of CC (sub-child)
cc = CC()
cc.m1()  # Inherited from P
cc.m2()  # Inherited from C
cc.m3()  # Defined in CC

# Output : 
Parent method  
Child method  
Sub-child method
</code></pre>
  </div>
<br><br>

<h3><b>Multiple Inheritance :</b></h3>
<p>When a class is <b>derived from more than one base class,</b> it is called <b>multiple inheritance.</b><br>
The derived class inherits <b>all accessible attributes and methods</b> from all parent classes.</b></p>
<br>
<h3><b>Structure :</b></h3>
<div class="Code-box">
    <pre><code>    P1       P2
     \       /
      \     /
        ‚Üì
        C (Child)
</code></pre>
  </div>
<br>

<h3><b>Example :</b></h3>
<div class="Code-box">
    <pre><code>class P1:
    def m1(self):
        print("Parent 1 method")

class P2:
    def m2(self):
        print("Parent 2 method")

class C(P1, P2):  # Inheriting from both P1 and P2
    def m3(self):
        print("Child method")

# Create object of child class
c = C()
c.m1()   # Inherited from P1
c.m2()   # Inherited from P2
c.m3()   # Defined in C

# Output : 
Parent 1 method  
Parent 2 method  
Child method
</code></pre>
  </div>
<br><br>


<h3><b>Hierarchical Inheritance :</b></h3>
<p>In <b>Hierarchical Inheritance, multiple subclasses are derived from a single superclass.</b><br>
Each child class gets access to the parent class's properties and methods.</p>
<br>
<h3><b>Structure :</b></h3>
<div class="Code-box">
    <pre><code>         P
       /   \
     C1     C2
</code></pre>
  </div>
<br>

<h3><b>Example :</b></h3>
<div class="Code-box">
    <pre><code>class P:
    def m1(self):
        print("Parent class")

class C1(P):  # Inherits from P
    def m2(self):
        print("Child 1 method")

class C2(P):  # Inherits from P
    def m3(self):
        print("Child 2 method")

# Object of C1
c = C1()
c.m1()   # Inherited from P
c.m2()   # Defined in C1

# Object of C2
c = C2()
c.m3()   # Defined in C2
# c.m2() # ‚ùå Not allowed: m2() belongs to C1, not C2

# Output : 
Parent class  
Child 1 method  
Child 2 method
</code></pre>
  </div>
<br><br>

<h3><b>Hybrid Inheritance :</b></h3>
<p><b>Hybrid Inheritance</b> is a combination of <b>two or more types of inheritance,</b> such as <b>multiple</b> and <b>multilevel</b> inheritance.</p>
<br>
<h3><b>Structure :</b></h3>
<div class="Code-box">
    <pre><code>       A
      / \
     B   C
      \ /
       D
</code></pre>
  </div>
<ul>
  <li><b>B</b> and <b>C</b> inherit from <b>A (multilevel inheritance)</b></li>
  <li><b>D</b> inherits from both <b>B</b> and <b>C (multiple inheritance)</b></li>
</ul>
<br>

<h3><b>Example :</b></h3>
<div class="Code-box">
    <pre><code>class A:
    def m1(self):
        print("Class A method")

class B(A):  # Inherits from A
    def m2(self):
        print("Class B method")

class C(A):  # Inherits from A
    def m3(self):
        print("Class C method")

class D(B, C):  # Inherits from both B and C (Hybrid)
    def m4(self):
        print("Class D method")

# Creating object of class D
d = D()
d.m1()  # From class A
d.m2()  # From class B
d.m3()  # From class C
d.m4()  # From class D

# Output : 
Class A method  
Class B method  
Class C method  
Class D method
</code></pre>
  </div>
<br><br>

<h3><b>Create a Car Class with Attributes and Info Display Method</b></h3>
<div class="Code-box">
    <pre><code>class Car:
    def __init__(self, name, model, color):
        self.name = name
        self.model = model
        self.color = color

    def getinfo(self):
        print("Car Name:", self.name)
        print("Car Model:", self.model)
        print("Car Color:", self.color)

c = Car("Maruti 800", 800, "White")
c.getinfo()

# Output : 
Car Name: Maruti 800  
Car Model: 800  
Car Color: White
</code></pre>
  </div>
<br><br>


<h3><b>Class Containing Object of Another Class (Has-A Relationship)</b></h3>
<p>In this example, an <b>Employee has a Car.</b></p>
<p>This is a real-world relationship modeled using <b>object composition,</b> which promotes reusability and modularity.</p>
<div class="Code-box">
    <pre><code>class Car:
    def __init__(self, name, model, color):
        self.name = name
        self.model = model
        self.color = color

    def getinfo(self):
        print("Car Name:", self.name)
        print("Car Model:", self.model)
        print("Car Color:", self.color)

class Employee:
    def __init__(self, eno, ename, car):
        self.eno = eno
        self.ename = ename
        self.car = car  # Car object is passed as an argument

    def empinfo(self):
        print("Employee NO:", self.eno)
        print("Employee Name:", self.ename)
        print("Car Information --->")
        self.car.getinfo()  # Calling Car class method from Employee

# Creating Objects:
c = Car("Maruti 800", 800, "White")
e = Employee(100, "Satish", c)
e.empinfo()

# Output : 
Employee NO: 100  
Employee Name: Satish  
Car Information --->  
Car Name: Maruti 800  
Car Model: 800  
Car Color: White
</code></pre>
  </div>
<br><br>


<h2><b>super() Method in Python (OOP) :</b></h2>
<p><b>super()</b> is a <b>built-in function</b> in Python used in <b>inheritance</b> to access methods and attributes of the <b>parent (super) class</b> from the <b>child (sub) class.</b></p>
<br>
<h3><b>Key Points :</b></h3>
<ol>
  <li><b>Used in Inheritance</b> to call methods or constructors from the parent class.</li>
  <li>Avoids code duplication ‚Äî helps follow the <b>DRY (Don't Repeat Yourself)</b> principle.</li>
  <li>Returns a <b>temporary object</b> of the <b>parent class,</b> through which you can access parent methods.</li>
  <li>Useful when <b>method overriding</b> is involved.</li>
  <li>Supports <b>multiple inheritance</b> with Python's <b>MRO (Method Resolution Order).</b></li>
</ol><br>
<h3><b>Syntax :</b></h3>
<div class="Code-box">
    <pre><code>super().method_name()
</code></pre>
  </div>
  <br>
  <h3><b>Example :</b></h3>
<div class="Code-box">
    <pre><code>class Animal:
    def __init__(self):
        print("Animal constructor")

    def speak(self):
        print("Animal speaks")

class Dog(Animal):
    def __init__(self):
        super().__init__()  # Call parent constructor
        print("Dog constructor")

    def speak(self):
        super().speak()  # Call parent method
        print("Dog barks")

d = Dog()
d.speak()

# Output : 
Animal constructor  
Dog constructor  
Animal speaks  
Dog barks
</code></pre>
  </div>
<br><br>

<h3><b>Why use super( )? </b></h3>
<br>
<div class="responsive-table-wrapper">
<table class="array-methods-table">
  <thead>
    <tr>
      <th>Feature</th>
      <th>Benefit</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>Reusability</code></td>
      <td>Use parent methods without rewriting</td>
    </tr>

    <tr>
      <td><code>Clean Code</code></td>
      <td>Avoids code duplication</td>
    </tr>

    <tr>
      <td><code>Extensibility</code></td>
      <td>Easily extend functionality</td>
    </tr>

     <tr>
      <td><code>Multiple Inheritance</code></td>
      <td>Works with Python‚Äôs MRO (C3 Linearization)</td>
    </tr>
  </tbody>
</table>
</div><br><br>

<h2><b>4. Polymorphism :</b></h2>
<p><b>I. Polymorphism</b> means having  <b>"many forms".</b></p>
<p><b>II. </b>It is derived from <b>two Greek words:</b></p>
<ol>
  <li><b>Poly</b> ‚Üí many</li>
  <li><b>Morphe</b> ‚Üí forms</li>
</ol>
<p><b>III. Polymorphism</b> is an ability by which message. is <b>displayed in many Forms.</b></p>
<p><b>IV. </b>more than one form is called Polymorphism.</p>
<br>

<h3><b>In Simple Terms :</b></h3>
<p><b>Polymorphism</b> allows the <b>same method name</b> to be used for <b>different types</b> (or classes), providing <b>different behaviors</b> depending on the object or class context.</p>
<br><br>

<h3><b>Real-life Example :</b></h3>
<p>A woman can have different roles :</p>
<ul>
  <li>At school: she is a <b>teacher</b></li>
  <li>At home: she is a <b>mother, wife, or daughter</b></li>
  <li>At the market: she is a <b>customer</b></li>
</ul>
<p>Though she is the same person, her behavior changes depending on the context. This is Polymorphism.</p>
<br><br>

<h3><b>Types of Polymorphism in Python : </b></h3>
<br>
<div class="responsive-table-wrapper">
<table class="array-methods-table">
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code><b>Compile-time Polymorphism</b> (not native in Python)	</code></td>
      <td>Achieved using method overloading (limited in Python)</td>
    </tr>

    <tr>
      <td><code><b>Runtime Polymorphism</b></code></td>
      <td>Achieved through method overriding</td>
    </tr>
  </tbody>
</table>
</div><br><br>

<h3><b>Example in Python (Runtime Polymorphism) :</b></h3>
<div class="Code-box">
    <pre><code>class Bird:
    def fly(self):
        print("Some birds can fly")

class Sparrow(Bird):
    def fly(self):
        print("Sparrow flies high")

class Ostrich(Bird):
    def fly(self):
        print("Ostriches cannot fly")

# Same method, different behavior
for bird in (Sparrow(), Ostrich()):
    bird.fly()

# Output : 
Sparrow flies high  
Ostriches cannot fly
</code></pre>
  </div>
<br><br>

<h3><b>Key Benefits of Polymorphism : </b></h3>
<ul>
  <li>Promotes <b>code reusability</b></li>
  <li>Makes code <b>cleaner and more flexible</b></li>
  <li>Supports <b>dynamic method resolution</b></li>
</ul>

<br><br>

<h3><b>Real-World Example of Polymorphism in Python :</b></h3>
<div class="Code-box">
    <pre><code>class India():
    def capital(self):
        print("New Delhi is the capital of India.")

    def language(self):
        print("Hindi is the most widely spoken language of India.")

    def type(self):
        print("India is a developing country.")

class USA():
    def capital(self):
        print("Washington, D.C. is the capital of USA.")

    def language(self):
        print("English is the primary language of USA.")

    def type(self):
        print("USA is a developed country.")

# Creating objects
obj_ind = India()
obj_usa = USA()

# Demonstrating Polymorphism
for country in (obj_ind, obj_usa):
    country.capital()
    country.language()
    country.type()

# Output : 
New Delhi is the capital of India.
Hindi is the most widely spoken language of India.
India is a developing country.
Washington, D.C. is the capital of USA.
English is the primary language of USA.
USA is a developed country.
</code></pre>
  </div>

<h3><b>Explanation :</b></h3>
<p>In this example :</p>
<ul>
  <li>Both <b>India</b> and <b>USA</b> classes have the <b>same method names: capital( ), language( ), and type( ).</b></li>
  <li>Even though the method names are the same, their <b>implementations are different</b> for each country.</li>
  <li>When iterating over objects of both classes, <b>polymorphism allows the same method calls (country.capital( )</b>, etc.) to behave differently based on the object.</li>
</ul>
<br>

<h2><b>Method Overloading in Python : </b></h2>
<p><b>Method Overloading</b> is the ability to define <b>multiple methods</b> in the <b>same class with the same name but different parameters</b> (in number or type).</p>
<br><br>

<h3><b>üîí Note :</b></h3>
<p><b>Python does not support traditional method overloading</b> like Java or C++. Instead, Python handles this using <b>default arguments, *args,</b> or manual parameter checking inside a method.</p>
<br>

<h3><b>üî∏Example (that won‚Äôt work in Python) :</b></h3>
<div class="Code-box">
    <pre><code>class Demo:
    def show(self, a):
        print("One argument:", a)

    def show(self, a, b):
        print("Two arguments:", a, b)

obj = Demo()
obj.show(10)  # ‚ùå Error: missing 1 required positional argument
</code></pre>
  </div>
<h3><b>Explanation :</b></h3>
<p>Only the <b>last show( ) method is kept,</b> the first one is <b>overwritten.</b></p>
<br><br>

<h2><b>How to Simulate Method Overloading in Python </b></h2>
<h3><b>Using Default Arguments :</b></h3>
<div class="Code-box">
    <pre><code>class Demo:
    def show(self, a=None, b=None):
        if a is not None and b is not None:
            print("Two arguments:", a, b)
        elif a is not None:
            print("One argument:", a)
        else:
            print("No arguments")

obj = Demo()
obj.show()
obj.show(10)
obj.show(10, 20)

# Output : 
No arguments  
One argument: 10  
Two arguments: 10 20
</code></pre>
  </div>
<br><br>

<h3><b>Using *args :</b></h3>
<div class="Code-box">
    <pre><code>class Demo:
    def show(self, *args):
        for arg in args:
            print("Argument:", arg)

obj = Demo()
obj.show(10)
obj.show(10, 20, 30)
</code></pre>
  </div>
<br>

<h2><b>Method Overriding in Python : </b></h2>
<p><b>Method Overriding</b> occurs when a <b>child class</b> defines a method with the <b>same name and signature</b> (same number of parameters) as in its <b>parent class.</b></p>
<p>This allows the child class to provide a <b>specific implementation</b> of a method that is already defined in the parent class.</p>
<br>

<h3><b>Key Features : </b></h3>
<ul>
  <li>Overriding happens <b>automatically</b> if the method name and parameters match.</li>
  <li>It helps in <b>customizing or extending</b> the behavior of the parent class method.</li>
  <li>Avoids code duplication (follows the DRY principle).</li>
</ul>
<br><br>

<h3><b>Example 1: Basic Method Inheritance (No Overriding) :</b></h3>
<div class="Code-box">
    <pre><code>class P:
    def property(self):
        print("cash + gold + car + house")

class C(P):
    pass

c = C( )
c.property( )  # Output: cash + gold + car + house
</code></pre>
  </div>
<p><b>No overriding</b> here. The method from the parent class is inherited as-is.</p>
<br><br>

<h3><b>Example 2: Child Class Adds New Method :</b></h3>
<div class="Code-box">
    <pre><code>class P:
    def property(self):
        print("Gold, money, car")

class C(P):
    def job(self):
        print("Software Engineer")

c = C()
c.property()  # Output: Gold, money, car (from parent)
c.job()       # Output: Software Engineer (from child)
</code></pre>
  </div>
<p>This shows <b>inheritance + extension,</b> not overriding yet.</p>
<br><br>

<h3><b>Example 3: Method Overriding :</b></h3>
<div class="Code-box">
    <pre><code>class Animal:
    def sound(self):
        print("This is a generic animal sound")

class Dog(Animal):
    def sound(self):
        print("Dog: Bark")

class Cat(Animal):
    def sound(self):
        print("Cat: Meow")

# Create instances
dog = Dog()
cat = Cat()

dog.sound()  # Output: Dog: Bark
cat.sound()  # Output: Cat: Meow
</code></pre>
  </div>
<p> Here, <b>sound( ) </b>is overridden in both child classes to provide specific behavior.</p>
<br><br>

<h3><b>Diagram: Method Overriding :</b></h3>
<div class="Code-box">
    <pre><code>      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
      ‚îÇ  Parent    ‚îÇ
      ‚îÇ  Class     ‚îÇ
      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ
     defines `sound()`
           ‚îÇ
      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îê
      ‚îÇ  Child  ‚îÇ   ‚Üê Overrides `sound()`
      ‚îÇ  Class  ‚îÇ   ‚Üê with own logic
      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre>
  </div>
<br><br>

<h2><b>Operator Overloading in Python (OOP)</b></h2>
<p><b>Operator Overloading</b> means giving <b>extra/custom functionality</b> to <b>standard Python operators 
  (like +, -, *, etc.)</b> so they can work with <b>user-defined objects</b> (classes).</p>
<br><br>

<h3><b>Why Use It?</b></h3>
<p>Python allows us to <b>change the behavior of operators</b> when they're used with <b>objects of user-defined classes.</b></p><br>
<h3><b>For example :</b></h3>
<ul>
  <li><b>+ </b>adds integers: <b>10 + 20 ‚Üí 30</b></li>
  <li><b>+</b> joins strings: <b>'a' + 'b' ‚Üí 'ab'</b></li>
  <li><b>+</b> merges lists: <b>[1, 2] + [3] ‚Üí [1, 2, 3]</b></li>
</ul>
<p>This is possible because the <b>+</b> operator is overloaded in the <b>int, str, and list</b> classes.</p>
<br><br>

<h3><b>Example: Without Operator Overloading :</b></h3>
<div class="Code-box">
    <pre><code>class Book:
    def __init__(self, pages):
        self.pages = pages

b1 = Book(100)
b2 = Book(200)

# print(b1 + b2)  ‚ùå Error: unsupported operand type(s)
</code></pre>
  </div>
<br><br>

<h3><b>With Operator Overloading :</b></h3>
<div class="Code-box">
    <pre><code>class Book:
    def __init__(self, pages):
        self.pages = pages

    def __add__(self, other):
        return self.pages + other.pages

b1 = Book(100)
b2 = Book(200)
print("Total pages:", b1 + b2)  # Output: Total pages: 300
</code></pre>
  </div>
<br><br>

<h3><b>Common Magic Methods (Dunder Methods) : </b></h3>
<br>
<div class="responsive-table-wrapper">
<table class="array-methods-table">
  <thead>
    <tr>
      <th>Operator</th>
      <th>Method</th>
      <th>Example Use</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code><b>+</code></td>
      <td>__add__</td>
      <td>a + b</td>
    </tr>

    <tr>
      <td><code><b>-</b></code></td>
      <td>__sub__</td>
      <td>a - b</td>
    </tr>

    <tr>
      <td><code><b>*</b></code></td>
      <td>__mul__</td>
      <td>a * b</td>
    </tr>

    <tr>
      <td><code><b>/</b></code></td>
      <td>__truediv__</td>
      <td>a / b</td>
    </tr>

    <tr>
      <td><code><b>==</b></code></td>
      <td>__eq__</td>
      <td>a == b</td>
    </tr>

    <tr>
      <td><code><b><</b></code></td>
      <td>__lt__</td>
      <td>a < b</td>
    </tr>

    <tr>
      <td><code><b>></b></code></td>
      <td>	__gt__</td>
      <td>a > b</td>
    </tr>
  </tbody>
</table>
</div><br><br><br>

<h3><b>Operator Overloading in Python Using __add__ Method :</b></h3>
<div class="Code-box">
    <pre><code>class Book:
    def __init__(self,pages):
        self.pages = pages
    def __add__(self, other):
        return self.pages+other.pages
b1 = Book(100)
b2 = Book(200)        #Magic Method
print(b1+b2)      # Output - 300
</code></pre>
  </div>
<br>

<!-- Common OOP Questions in Python -->
<div class="pillars-btn-section" style="text-align:center; margin:40px 0;">
  <button class="pillars-animated-btn" onclick="window.location.href='common_oop.html'">
    <span>‚ú® Common OOP Questions in Python ‚ú®</span>
  </button>
</div><br><br>

  <div class="navigation-buttons">
  <a href="oops.html" class="nav-btn prev-btn">‚Üê Previous</a>
</div>
</section>



<footer class="footer">
  <div class="footer-container">
    <div class="footer-left">
      <h2>CodeWith <span>Vikas</span></h2>
      <p>Learn programming from scratch.<br> Start your journey today!</p>
    </div>

    <div class="footer-links">
      <h3>Quick Links</h3>
      <ul>
        <li><a href="#">Home</a></li>
        <li><a href="#">Python</a></li>
        <li><a href="#">Java</a></li>
        <li><a href="#">Contact</a></li>
      </ul>
    </div>

    <div class="footer-social">
      <h3>Follow Me</h3>
      <a href="#"><i class="fab fa-facebook-f"></i></a>
      <a href="#"><i class="fab fa-x"></i></a>
      <a href="#"><i class="fab fa-instagram"></i></a>
      <a href="#"><i class="fab fa-github"></i></a>
    </div>
  </div>

  <div class="footer-bottom">
    <p>&copy; 2025 TechWith Vikas | Created by Vikas Mishra</p>
  </div>
<div class="scroll-to-top" title="Go to Top">
  <i class="fa fa-arrow-up"></i>
</div>
</footer>

<script src="../main.js"></script>
</body>
</html>
